<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Draw Your Signature</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #f5f7fa;
    color: #1a1a2e;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    padding: 16px;
  }
  .container {
    max-width: 560px;
    width: 100%;
    margin: 0 auto;
  }
  h1 {
    color: #1a3c5e;
    font-size: 1.4rem;
    margin-bottom: 8px;
  }
  .subtitle {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 6px;
  }
  .instructions {
    color: #888;
    font-size: 0.85rem;
    line-height: 1.5;
    margin-bottom: 20px;
  }
  .section {
    background: #fff;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 16px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  }
  .section-label {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #1a3c5e;
    margin-bottom: 10px;
  }
  .canvas-wrapper {
    position: relative;
    border: 2px solid #e2e8f0;
    border-radius: 6px;
    background: #fff;
    touch-action: none;
  }
  .canvas-wrapper.active { border-color: #1a3c5e; }
  canvas {
    display: block;
    width: 100%;
    cursor: crosshair;
  }
  .canvas-hint {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #aaa;
    font-size: 0.9rem;
    pointer-events: none;
    transition: opacity 0.2s;
  }
  .canvas-hint.hidden { opacity: 0; }
  .clear-btn {
    margin-top: 8px;
    background: none;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 0.85rem;
    color: #666;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }
  .clear-btn:hover { border-color: #999; color: #333; }
  .submit-btn {
    width: 100%;
    padding: 16px;
    background: #1a3c5e;
    color: #fff;
    border: none;
    border-radius: 8px;
    font-size: 1.05rem;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
    -webkit-tap-highlight-color: transparent;
    -webkit-appearance: none;
  }
  .submit-btn:hover:not(:disabled) { background: #245080; }
  .submit-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .status {
    text-align: center;
    padding: 40px 20px;
  }
  .status.error { color: #c0392b; }
  .status.success { color: #1a3c5e; }
  .status h2 { margin-bottom: 8px; }
  .success-icon {
    font-size: 64px;
    color: #27ae60;
    margin-bottom: 16px;
  }
  .success-message {
    color: #666;
    margin-bottom: 24px;
  }
  .next-step {
    background: #f0f7ff;
    border: 2px solid #1a3c5e;
    border-radius: 8px;
    padding: 20px;
    margin: 24px 0;
  }
  .next-step-title {
    font-weight: 600;
    color: #1a3c5e;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 8px;
  }
  .next-step-action {
    font-size: 18px;
    color: #1a3c5e;
    font-weight: 500;
    margin: 0;
  }
  .spinner {
    display: inline-block;
    width: 24px;
    height: 24px;
    border: 3px solid #e2e8f0;
    border-top-color: #1a3c5e;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 12px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .hidden { display: none !important; }
  /* Driver's license upload */
  .dl-section { margin-bottom: 16px; }
  .dl-upload-area {
    border: 2px dashed #d1d5db;
    border-radius: 8px;
    padding: 24px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }
  .dl-upload-area:hover { border-color: #1a3c5e; background: #f8fafc; }
  .dl-upload-area.has-image { border-style: solid; border-color: #27ae60; cursor: default; }
  .dl-upload-icon { font-size: 2rem; margin-bottom: 8px; }
  .dl-upload-text { font-size: 0.9rem; color: #666; }
  .dl-upload-text strong { color: #1a3c5e; }
  .dl-preview { position: relative; display: inline-block; max-width: 100%; }
  .dl-preview img { max-width: 100%; max-height: 200px; border-radius: 4px; display: block; }
  .dl-remove-btn {
    position: absolute; top: 6px; right: 6px;
    background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 50%;
    width: 28px; height: 28px; font-size: 1rem; cursor: pointer; line-height: 28px; text-align: center;
  }
  .dl-remove-btn:hover { background: rgba(192,57,43,0.9); }
  .dl-file-input { display: none; }
  .dl-optional { font-size: 0.75rem; color: #999; font-weight: 400; }
  /* QR desktop-to-mobile bridge */
  .qr-bridge { text-align: center; margin: 20px 0; padding: 16px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; }
  .qr-bridge svg { margin: 12px auto; display: block; }
  .qr-bridge-title { font-size: 0.85rem; font-weight: 600; color: #1a3c5e; margin-bottom: 4px; }
  .qr-bridge-subtitle { font-size: 0.8rem; color: #888; }
  .qr-divider { display: flex; align-items: center; gap: 12px; margin: 16px 0; color: #aaa; font-size: 0.8rem; }
  .qr-divider::before, .qr-divider::after { content: ''; flex: 1; border-top: 1px solid #e2e8f0; }
</style>
</head>
<body>
<div class="container">
  <!-- Loading state -->
  <div id="loading" class="status">
    <div class="spinner"></div>
    <p>Loading signing session...</p>
  </div>

  <!-- Error state -->
  <div id="error" class="status error hidden">
    <h2>Unable to Load</h2>
    <p id="error-message"></p>
  </div>

  <!-- Success state (only shown if auto-close failed) -->
  <div id="success" class="status success hidden">
    <div class="success-icon">âœ“</div>
    <h2>Signature Submitted Successfully</h2>
    <p class="success-message">Your signature has been securely encrypted and submitted.</p>
    <div class="next-step">
      <p class="next-step-title">You can close this tab now</p>
      <p class="next-step-action">Return to your AI assistant to continue.</p>
    </div>
  </div>

  <!-- Main signing form -->
  <div id="sign-form" class="hidden">
    <h1>Draw Your Signature</h1>
    <p class="subtitle" id="signer-greeting"></p>
    <p class="instructions" id="instructions-text"></p>

    <div class="section">
      <div class="section-label">Your Signature</div>
      <div class="canvas-wrapper" id="canvas-wrapper">
        <canvas id="sig-canvas" height="150"></canvas>
        <div class="canvas-hint" id="canvas-hint">Draw your signature here</div>
      </div>
      <button class="clear-btn" id="clear-btn">Clear</button>
    </div>

    <!-- Driver's license upload (shown conditionally) -->
    <div id="dl-section" class="section dl-section hidden">
      <div class="section-label">Driver's License <span class="dl-optional">(Optional)</span></div>
      <div id="dl-upload-area" class="dl-upload-area">
        <div class="dl-upload-icon">ðŸ“·</div>
        <div class="dl-upload-text"><strong>Tap to take a photo</strong> or upload an image</div>
      </div>
      <div id="dl-preview-wrapper" class="dl-preview hidden">
        <img id="dl-preview-img" alt="Driver's license preview">
        <button class="dl-remove-btn" id="dl-remove-btn" title="Remove">âœ•</button>
      </div>
      <input type="file" id="dl-file-input" class="dl-file-input" accept="image/*" capture="environment">
    </div>

    <!-- QR code bridge for desktop users -->
    <div id="qr-bridge" class="qr-bridge hidden">
      <div class="qr-bridge-title">ðŸ“± Or complete on your phone</div>
      <div class="qr-bridge-subtitle">Scan to sign &amp; capture your ID with your phone camera</div>
      <div id="qr-code"></div>
    </div>

    <button class="submit-btn" id="submit-btn" disabled>Submit Signature</button>
  </div>
</div>

<script>
(async () => {
  const $ = (s) => document.querySelector(s);
  const sessionId = window.location.pathname.split('/sign/')[1]?.split('?')[0];
  if (!sessionId) return showError('No session ID found in URL.');

  let serverPublicKey, instructions, signerName, requestDriversLicense;
  let hasDrawn = false;
  let dlDataUrl = null; // driver's license image data URL

  // --- Load session info ---
  try {
    const res = await fetch(`/api/signatures/sessions/${sessionId}/info`);
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      if (res.status === 410) return showError('This signing session has expired. Please request a new link.');
      if (res.status === 409) return showError('This authorization has already been signed.');
      return showError(err.error || 'Session not found.');
    }
    const data = await res.json();
    serverPublicKey = data.publicKeyJwk;
    instructions = data.instructions;
    signerName = data.signerName;
    requestDriversLicense = data.requestDriversLicense;
  } catch (e) {
    return showError('Could not connect to the server. Please try again.');
  }

  // --- Populate UI ---
  $('#instructions-text').textContent = instructions;
  if (signerName) {
    $('#signer-greeting').textContent = `Hello ${signerName}`;
  }
  $('#loading').classList.add('hidden');
  $('#sign-form').classList.remove('hidden');

  // --- Canvas setup ---
  const canvas = $('#sig-canvas');
  const ctx = canvas.getContext('2d');
  const wrapper = $('#canvas-wrapper');
  const dpr = Math.max(window.devicePixelRatio || 1, 2);

  function resizeCanvas() {
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = 150 * dpr;
    canvas.style.height = '150px';
    ctx.scale(dpr, dpr);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#1a1a2e';
  }
  resizeCanvas();
  window.addEventListener('resize', () => { resizeCanvas(); hasDrawn = false; updateSubmitState(); });

  let drawing = false;
  let lastX, lastY;

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
  }

  function startDraw(e) {
    e.preventDefault();
    drawing = true;
    const p = getPos(e);
    lastX = p.x; lastY = p.y;
    wrapper.classList.add('active');
    $('#canvas-hint').classList.add('hidden');
  }

  function draw(e) {
    if (!drawing) return;
    e.preventDefault();
    const p = getPos(e);
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    lastX = p.x; lastY = p.y;
    hasDrawn = true;
    updateSubmitState();
  }

  function endDraw(e) {
    if (e) e.preventDefault();
    drawing = false;
    wrapper.classList.remove('active');
  }

  canvas.addEventListener('pointerdown', startDraw);
  canvas.addEventListener('pointermove', draw);
  canvas.addEventListener('pointerup', endDraw);
  canvas.addEventListener('pointerleave', endDraw);

  $('#clear-btn').addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
    hasDrawn = false;
    $('#canvas-hint').classList.remove('hidden');
    updateSubmitState();
  });

  // --- Driver's license upload ---
  if (requestDriversLicense) {
    $('#dl-section').classList.remove('hidden');
    const dlInput = $('#dl-file-input');
    const dlUploadArea = $('#dl-upload-area');
    const dlPreviewWrapper = $('#dl-preview-wrapper');
    const dlPreviewImg = $('#dl-preview-img');

    dlUploadArea.addEventListener('click', () => dlInput.click());

    function resizeImage(file, maxWidth) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          let w = img.width, h = img.height;
          if (w > maxWidth) { h = Math.round(h * maxWidth / w); w = maxWidth; }
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          c.getContext('2d').drawImage(img, 0, 0, w, h);
          resolve(c.toDataURL('image/png'));
        };
        img.src = URL.createObjectURL(file);
      });
    }

    dlInput.addEventListener('change', async () => {
      const file = dlInput.files[0];
      if (!file) return;
      dlDataUrl = await resizeImage(file, 1600);
      dlPreviewImg.src = dlDataUrl;
      dlUploadArea.classList.add('hidden');
      dlPreviewWrapper.classList.remove('hidden');
    });

    $('#dl-remove-btn').addEventListener('click', () => {
      dlDataUrl = null;
      dlInput.value = '';
      dlPreviewWrapper.classList.add('hidden');
      dlUploadArea.classList.remove('hidden');
    });
  }

  // --- QR code bridge for desktop ---
  const isDesktop = !window.matchMedia('(pointer: coarse)').matches && window.innerWidth > 768;
  if (isDesktop) {
    $('#qr-bridge').classList.remove('hidden');
    generateQR($('#qr-code'), window.location.href);
    // Poll for session completion from another device
    (async () => {
      while (true) {
        await new Promise(r => setTimeout(r, 3000));
        try {
          const res = await fetch(`/api/signatures/sessions/${sessionId}/poll?timeout=1`);
          if (!res.ok) continue;
          const data = await res.json();
          if (data.status === 'completed') {
            $('#sign-form').classList.add('hidden');
            $('#success').classList.remove('hidden');
            return;
          }
          if (data.status === 'expired') {
            showError('This signing session has expired.');
            return;
          }
        } catch {}
      }
    })();
  }

  // --- Form validation ---
  function updateSubmitState() {
    $('#submit-btn').disabled = !hasDrawn;
  }

  // --- Submit with E2EE ---
  $('#submit-btn').addEventListener('click', async () => {
    $('#submit-btn').disabled = true;
    $('#submit-btn').textContent = 'Encrypting & Submitting...';

    try {
      // Crop to bounding box of drawn strokes (with padding)
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { data, width, height } = imgData;
      let minX = width, minY = height, maxX = 0, maxY = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (data[(y * width + x) * 4 + 3] > 0) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      const pad = Math.round(8 * dpr);
      minX = Math.max(0, minX - pad);
      minY = Math.max(0, minY - pad);
      maxX = Math.min(width - 1, maxX + pad);
      maxY = Math.min(height - 1, maxY + pad);
      const cropW = maxX - minX + 1;
      const cropH = maxY - minY + 1;
      const cropped = ctx.getImageData(minX, minY, cropW, cropH);
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = cropW;
      tmpCanvas.height = cropH;
      tmpCanvas.getContext('2d').putImageData(cropped, 0, 0);
      const sigDataUrl = tmpCanvas.toDataURL('image/png');

      // Build payload
      const payloadObj = {
        signatureImage: sigDataUrl,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
      };
      if (dlDataUrl) payloadObj.driversLicenseImage = dlDataUrl;
      const payload = JSON.stringify(payloadObj);

      // Import server's public key
      const serverKey = await crypto.subtle.importKey(
        'jwk', serverPublicKey, { name: 'ECDH', namedCurve: 'P-256' }, false, []
      );

      // Generate ephemeral keypair
      const ephemeral = await crypto.subtle.generateKey(
        { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveBits']
      );

      // Derive shared secret
      const sharedBits = await crypto.subtle.deriveBits(
        { name: 'ECDH', public: serverKey }, ephemeral.privateKey, 256
      );

      // Use shared secret as AES-GCM key
      const aesKey = await crypto.subtle.importKey(
        'raw', sharedBits, 'AES-GCM', false, ['encrypt']
      );

      // Encrypt
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv }, aesKey, new TextEncoder().encode(payload)
      );

      // Export ephemeral public key
      const ephPubJwk = await crypto.subtle.exportKey('jwk', ephemeral.publicKey);

      // Submit
      const res = await fetch(`/api/signatures/sessions/${sessionId}/submit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ciphertext: bufToBase64(encrypted),
          iv: bufToBase64(iv),
          ephemeralPublicKey: ephPubJwk,
        }),
      });

      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || 'Submission failed');
      }

      // Try to auto-close the window
      window.close();
      
      // If we're still here, auto-close didn't work - show manual instructions
      $('#sign-form').classList.add('hidden');
      $('#success').classList.remove('hidden');
    } catch (e) {
      alert('Error submitting signature: ' + e.message);
      $('#submit-btn').disabled = false;
      $('#submit-btn').textContent = 'Submit Signature';
    }
  });

  // --- Helpers ---
  function showError(msg) {
    $('#loading').classList.add('hidden');
    $('#error-message').textContent = msg;
    $('#error').classList.remove('hidden');
  }

  function bufToBase64(buf) {
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
  }
})();

// Minimal QR code SVG generator (QR Code Model 2, byte mode, EC level L)
function generateQR(container, text) {
  const mods = qrEncodeToModules(text);
  if (!mods) { container.textContent = text; return; }
  const size = mods.length;
  const cellSize = 4;
  const margin = 4;
  const svgSize = (size + margin * 2) * cellSize;
  let rects = '';
  for (let y = 0; y < size; y++)
    for (let x = 0; x < size; x++)
      if (mods[y][x])
        rects += `<rect x="${(x + margin) * cellSize}" y="${(y + margin) * cellSize}" width="${cellSize}" height="${cellSize}"/>`;
  container.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgSize} ${svgSize}" width="${Math.min(svgSize, 180)}" height="${Math.min(svgSize, 180)}" style="background:#fff"><g fill="#1a3c5e">${rects}</g></svg>`;
}

function qrEncodeToModules(text) {
  const data = new TextEncoder().encode(text);
  const len = data.length;
  // Pick smallest version that fits (byte mode, EC level L)
  const caps = [17,32,53,78,106,134,154,192,230,271,321,367,425,458,520,586,644,718,792,858];
  let ver = 0;
  for (let v = 0; v < caps.length; v++) { if (len <= caps[v]) { ver = v + 1; break; } }
  if (!ver) return null;
  const size = ver * 4 + 17;

  // EC parameters for level L
  const ecParams = [
    [19,7,1],[34,10,1],[55,15,1],[80,20,1],[108,26,1],[136,18,2],[156,20,2],[194,24,2],[232,30,2],[274,18,2,16,2],
    [324,20,4],[370,24,2,22,2],[428,26,4],[461,30,3,17,1],[523,22,5,15,1],[589,24,5,17,1],[647,28,1,15,5],[721,30,5,17,1],[795,28,3,15,4],[861,28,3,17,5]
  ];
  const ep = ecParams[ver - 1];
  const totalData = ep[0];
  const ecPerBlock = ep[1];
  const group1Blocks = ep[2] || 1;
  const group1DataCw = ep.length > 3 ? ep[3] : Math.floor(totalData / group1Blocks);
  const group2Blocks = ep.length > 4 ? ep[4] : 0;
  const group2DataCw = ep.length > 5 ? ep[5] : 0;

  // Encode data bits
  const bits = [];
  function pushBits(val, n) { for (let i = n - 1; i >= 0; i--) bits.push((val >> i) & 1); }
  pushBits(4, 4); // byte mode
  pushBits(len, ver <= 9 ? 8 : 16);
  for (const b of data) pushBits(b, 8);
  pushBits(0, Math.min(4, totalData * 8 - bits.length));
  while (bits.length % 8) bits.push(0);
  while (bits.length < totalData * 8) { pushBits(0xEC, 8); if (bits.length < totalData * 8) pushBits(0x11, 8); }

  const codewords = [];
  for (let i = 0; i < bits.length; i += 8)
    codewords.push(bits.slice(i, i + 8).reduce((a, b) => (a << 1) | b, 0));

  // Galois field for RS
  const gfExp = new Uint8Array(512), gfLog = new Uint8Array(256);
  let v = 1;
  for (let i = 0; i < 255; i++) { gfExp[i] = v; gfLog[v] = i; v = (v << 1) ^ (v >= 128 ? 0x11d : 0); }
  for (let i = 255; i < 512; i++) gfExp[i] = gfExp[i - 255];
  function gfMul(a, b) { return (a === 0 || b === 0) ? 0 : gfExp[(gfLog[a] + gfLog[b]) % 255]; }

  function rsEncode(data, ecLen) {
    const gen = [1];
    for (let i = 0; i < ecLen; i++) {
      const ng = new Array(gen.length + 1).fill(0);
      for (let j = 0; j < gen.length; j++) { ng[j] ^= gen[j]; ng[j + 1] ^= gfMul(gen[j], gfExp[i]); }
      gen.length = ng.length;
      for (let j = 0; j < ng.length; j++) gen[j] = ng[j];
    }
    const rem = new Uint8Array(ecLen);
    for (const b of data) {
      const lead = b ^ rem[0];
      for (let i = 0; i < ecLen - 1; i++) rem[i] = rem[i + 1] ^ gfMul(gen[i + 1], lead);
      rem[ecLen - 1] = gfMul(gen[ecLen], lead);
    }
    return rem;
  }

  // Split into blocks and generate EC
  const blocks = [];
  let offset = 0;
  for (let i = 0; i < group1Blocks; i++) { blocks.push(codewords.slice(offset, offset + group1DataCw)); offset += group1DataCw; }
  for (let i = 0; i < group2Blocks; i++) { blocks.push(codewords.slice(offset, offset + group2DataCw)); offset += group2DataCw; }
  const ecBlocks = blocks.map(b => rsEncode(b, ecPerBlock));

  // Interleave
  const interleaved = [];
  const maxDataCw = Math.max(group1DataCw, group2DataCw || 0);
  for (let i = 0; i < maxDataCw; i++) for (const b of blocks) if (i < b.length) interleaved.push(b[i]);
  for (let i = 0; i < ecPerBlock; i++) for (const b of ecBlocks) interleaved.push(b[i]);

  const allBits = [];
  for (const cw of interleaved) for (let i = 7; i >= 0; i--) allBits.push((cw >> i) & 1);

  // Build QR matrix
  const grid = Array.from({ length: size }, () => new Uint8Array(size));
  const reserved = Array.from({ length: size }, () => new Uint8Array(size));
  function setMod(x, y, val) { grid[y][x] = val ? 1 : 0; reserved[y][x] = 1; }

  // Finder patterns
  function drawFinder(cx, cy) {
    for (let dy = -4; dy <= 4; dy++) for (let dx = -4; dx <= 4; dx++) {
      const x = cx + dx, y = cy + dy;
      if (x < 0 || x >= size || y < 0 || y >= size) continue;
      const d = Math.max(Math.abs(dx), Math.abs(dy));
      setMod(x, y, d !== 2 && d !== 4);
    }
  }
  drawFinder(3, 3); drawFinder(size - 4, 3); drawFinder(3, size - 4);

  // Timing
  for (let i = 8; i < size - 8; i++) { setMod(i, 6, i % 2 === 0); setMod(6, i, i % 2 === 0); }

  // Alignment patterns
  const alignPos = ver === 1 ? [] : qrAlignPos(ver, size);
  for (const ay of alignPos) for (const ax of alignPos) {
    if (reserved[ay][ax]) continue;
    for (let dy = -2; dy <= 2; dy++) for (let dx = -2; dx <= 2; dx++)
      setMod(ax + dx, ay + dy, Math.abs(dx) === 2 || Math.abs(dy) === 2 || (dx === 0 && dy === 0));
  }

  // Reserve format & version areas
  for (let i = 0; i < 8; i++) {
    if (!reserved[8][i]) reserved[8][i] = 1;
    if (!reserved[i][8]) reserved[i][8] = 1;
    if (!reserved[8][size - 1 - i]) reserved[8][size - 1 - i] = 1;
    if (!reserved[size - 1 - i][8]) reserved[size - 1 - i][8] = 1;
  }
  reserved[8][8] = 1;
  setMod(8, size - 8, 1); // dark module

  if (ver >= 7) {
    for (let i = 0; i < 6; i++) for (let j = 0; j < 3; j++) {
      reserved[i][size - 11 + j] = 1;
      reserved[size - 11 + j][i] = 1;
    }
  }

  // Place data bits
  let bitIdx = 0;
  for (let right = size - 1; right >= 1; right -= 2) {
    if (right === 6) right = 5;
    for (let vert = 0; vert < size; vert++) {
      for (let j = 0; j < 2; j++) {
        const x = right - j;
        const upward = ((right + 1) / 2 | 0) % 2 === (ver > 6 ? 0 : 1);
        const y = upward ? size - 1 - vert : vert;
        if (reserved[y][x]) continue;
        if (bitIdx < allBits.length) grid[y][x] = allBits[bitIdx];
        bitIdx++;
      }
    }
  }

  // Apply mask 0 (checkerboard) and format info
  const masked = grid.map(r => r.slice());
  for (let y = 0; y < size; y++) for (let x = 0; x < size; x++)
    if (!reserved[y][x] && (x + y) % 2 === 0) masked[y][x] ^= 1;

  // Format bits for mask 0, EC level L
  const fmtBits = [1,1,1,0,1,1,1,1,1,0,0,0,1,0,0];
  const fmtP1 = [[8,0],[8,1],[8,2],[8,3],[8,4],[8,5],[8,7],[8,8],[7,8],[5,8],[4,8],[3,8],[2,8],[1,8],[0,8]];
  const fmtP2 = [[8,size-1],[8,size-2],[8,size-3],[8,size-4],[8,size-5],[8,size-6],[8,size-7],[size-8,8],[size-7,8],[size-6,8],[size-5,8],[size-4,8],[size-3,8],[size-2,8],[size-1,8]];
  for (const positions of [fmtP1, fmtP2])
    for (let i = 0; i < 15; i++) { const [y, x] = positions[i]; masked[y][x] = fmtBits[i]; }

  if (ver >= 7) {
    const vt = [0,0,0,0,0,0,0,0x07C94,0x085BC,0x09A99,0x0A4D3,0x0BBF6,0x0C762,0x0D847,0x0E60D,0x0F928,0x10B78,0x1145D,0x12A17,0x13532,0x149A6];
    const vb = vt[ver] || 0;
    for (let i = 0; i < 18; i++) {
      const bit = (vb >> i) & 1;
      const row = Math.floor(i / 3), col = i % 3;
      masked[row][size - 11 + col] = bit;
      masked[size - 11 + col][row] = bit;
    }
  }
  return masked;
}

function qrAlignPos(ver, size) {
  if (ver === 1) return [];
  const intervals = [0,0,0,0,0,0,0,16,18,20,22,24,26,28,20,22,24,24,26,28,28];
  const step = ver <= 20 ? intervals[ver] : 28;
  const positions = [6];
  let pos = size - 7;
  while (pos > 6) { positions.unshift(pos); pos -= step; }
  return positions;
}
</script>
</body>
</html>
